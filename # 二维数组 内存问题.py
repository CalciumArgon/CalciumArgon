# 二维数组 内存问题

# 用 * 来定义数组会带来相同的储存地址
# list dict 等结构中的元素可被修改, 因此list本身存储地址不会改变
# 而str tuple不能修改, 因此实际"修改"list中元素时所做的是"重赋值", 即重建一个新地址
from copy import deepcopy


a = [[0]*3] * 3

print(id(a))                                        # X
print(id(a[0][0]), id(a[1][0]), id(a[2][0]))        # A A A
print(id(a[0][1]), id(a[1][1]), id(a[2][1]))        # A A A

a[2][1] = -1
print(a)    # [[0, -1, 0], [0, -1, 0], [0, -1, 0]]

print(id(a))                                        # X
print(id(a[0][0]), id(a[1][0]), id(a[2][0]))        # A A A
print(id(a[0][1]), id(a[1][1]), id(a[2][1]))        # B B B


'''
a列表里元素是 str, 所以"重赋值", 变了地址, 则修改 a[2] 不影响其他位置.
b列表里元素是 list, 所以"修改", 没有变地址, 则修改 b[2][0] 影响了同一个地址下的所有值.

但注意要是 b[2] = 1, 即把 b[2] 这个列表换成字符串 1 , 那显然是"重赋值", 要更换地址, 不影响其他.
'''
a = [0] * 5
for i in range(5):
    print(id(a[i]))
print(a)            # [0, 0, 0, 0, 0]
a[2] = 1
print(a)            # [0, 0, 1, 0, 0]


b = [[0]] * 5
for i in range(5):
    print(id(b[i]))
print(b)            # [[0], [0], [0], [0], [0]]
b[2][0] = 1
print(b)            # [[1], [1], [1], [1], [1]]



x1 = list("sdhfvb")
x2 = x1
x3 = x1[:]
print(id(x1), id(x2), id(x3))   # x3 的地址和 x1x2 不相同



# 赋值语句会把 x, y 指向同一块内存地址, 具有相同的 id
# 如果 x 的类型属于"可修改", 那么修改 y 相当于修改 x

xa = [1, 2, 3]
xb = xa
print(f"{xa}: {id(xa)}, {xb}: {id(xb)}")    # 赋值, 地址相同
xa[2] = 4
print(f"{xa}: {id(xa)}, {xb}: {id(xb)}")    # 没改列表, 只是在同一个地址里改数据, 则x, y访问时都是改后的
xa = [1, 2, 5]
print(f"{xa}: {id(xa)}, {xb}: {id(xb)}")    # 把xa重新赋值了, 更换地址, 不会影响xb


d1 = [1 ,2, [3, 4, [5, 6]]]
d2 = d1.copy()
print(f"{d1}: {id(d1)}, {d2}: {id(d2)}")
d1[0] = 10
d1[2][0] = 30
d1[2][2][0] = 50
print(f"{d1}: {id(d1)}, {d2}: {id(d2)}")
print(f"d1[2][0]: {id(d1[2][0])}, d2[2][0]: {id(d2[2][0])}")
print(f"d1[2][2][0]: {id(d1[2][0])}, d2[2][2][0]: {id(d2[2][0])}")      # d1 与 d2 子列表地址仍然相同

d1 = [1 ,2, {"a":3, "b":4}]         # 只要内层是一个可修改的数据容器, 改里面的元素就仍然同一个地址
d2 = d1.copy()
d1[2]["a"] = 30
print(f"{d1}: {id(d1)}, {d2}: {id(d2)}")    # 均为 [1, 2, {'a': 30, 'b': 4}]

d1 = [1 ,2, [3, 4, [5, 6]]]
d2 = deepcopy(d1)
print(f"{d1}: {id(d1)}, {d2}: {id(d2)}")
d1[0] = 10
d1[2][0] = 30
d1[2][2][0] = 50
print(f"{d1}: {id(d1)}, {d2}: {id(d2)}")
print(f"d1[2][2][0]: {id(d1[2][0])}, d2[2][2][0]: {id(d2[2][0])}")





